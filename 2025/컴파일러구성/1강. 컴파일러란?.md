# 1강. 컴파일러란?

## 1. 컴파일러의 개념과 번역기의 종류

### 컴파일러란?

- 언어를 번역 - 번역기



### 번역기의 종류

<img src="./assets/Screenshot 2025-09-30 at 2.21.06 AM.png" alt="Screenshot 2025-09-30 at 2.21.06 AM" style="zoom:50%;" />

- 컴파일러는
  - 고급언어를 저급언어로 변환시켜주는 것

- 인터프리터
  - 번역과 동시에 실행까지 해 줌



### 컴파일러와 인터프리터

- 컴파일러 기법
  - 번역 후 실행
  - 효율적
  - 반복문 처리에 효과
  - 큰 기억장소 요구
  - FORTRAN, COBOL, PASCAL, C, C++, JAVA
- 인터프리터 기법
  - 번역과 실행
  - 실행시간이 김
  - 사용자와 대화식
  - 융통성
  - LISP, APL, SNOBOL
- 요즘 나오는 언어들은 컴파일러/인터프리터 기법을 혼합해서 사요됨



### 과목개설이유

- 컴파일러 구현의 어려움
  - 언어를 정확하게 번역하는 것이 어려움
- FORTRAN 컴파일러 구현 → 1957년도 
- 발전 과정
  - 연산자 우선순위 문법
  - bottom up: LR(K)
  - top down: LL(K)



### 영어 번역과 컴파일러

<img src="./assets/Screenshot 2025-11-05 at 11.51.52 PM.png" alt="Screenshot 2025-11-05 at 11.51.52 PM" style="zoom:40%;" />





## 2. 컴파일러의 논리적 구조

### 컴파일러의 논리적 구조

<img src="./assets/Screenshot 2025-11-05 at 11.54.08 PM.png" alt="Screenshot 2025-11-05 at 11.54.08 PM" style="zoom:50%;" />



### 논리적 구조 6단계

<img src="./assets/Screenshot 2025-11-06 at 12.36.12 AM.png" alt="Screenshot 2025-11-06 at 12.36.12 AM" style="zoom:50%;" />



### 1. 어휘분석

- 기본 어휘가 문법에 맞는지 분석
- 어휘를 토큰으로 변환
- 연산자, 식별자, 예약어, 구분자, 상수
- 어휘 분석: Lexical Analysis, Scan
- 어휘분석기: Lexical Analyzer, Scanner



### 2. 구문분석

- 구문이 문법에 맞는지 분석한다
- 분석결과를 파스트리로 출력
- 구문 분석: Syntax Analysis, Parse
- 구문분석기: Syntax Analyzer, Parser



#### 파스트리

<img src="./assets/Screenshot 2025-11-06 at 12.39.47 AM.png" alt="Screenshot 2025-11-06 at 12.39.47 AM" style="zoom:50%;" />

#### 구문트리(AST)

<img src="./assets/Screenshot 2025-11-06 at 12.40.13 AM.png" alt="Screenshot 2025-11-06 at 12.40.13 AM" style="zoom:50%;" />



### 3. 의미분석

- 파스트리에 의미 부여
- 실행 전 사전작업
- 자료구조정의, 혼합형 연산, 기호표
- ABC := E * 3.14 + ABC/E;



### 4. 중간코드

- 최적활르 위한 중간단계
- 후위표현
- 3주소코드: Quadruple
- U zhem
- 문법지시적 변환



### 5. 최적화

- 효율화
- 수행시간 최소화
- 기억공간 최소화



### 6. 목적코드 생성

- 사용할 레지스터의 수
- 계산과정
- 명령어 종류





## 3. 컴파일러의 물리적 구조

### 컴파일러의 논리적 구조와 물리적 구조

<img src="./assets/Screenshot 2025-11-06 at 12.43.43 AM.png" alt="Screenshot 2025-11-06 at 12.43.43 AM" style="zoom:50%;" />



### 1-패스(원패스) 컴파일러

- 효율성(기계코드 변환)
- 실행속도가 빠름
- backpatching
  - If (A OR B) AND C THEN



### 2-패스(투패스) 컴파일러

- 이식성(Portability)
- 기계독립적, 최적화
- 기억장소 절약
- 기계코드 표현 제약
- 실행속도 느림



## 4. 간단한 컴파일러 실행 예

### 컴파일러의 실행 예

- 연산자우선순위 이용
- 과정만 설명

```assembly
ABC := E * 3.14 + ABC / E;
```

<img src="./assets/Screenshot 2025-11-06 at 12.46.21 AM.png" alt="Screenshot 2025-11-06 at 12.46.21 AM" style="zoom:50%;" />



