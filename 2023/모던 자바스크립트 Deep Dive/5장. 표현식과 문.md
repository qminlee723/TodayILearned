# 5장. 표현식과 문

## 5.1 값

> 값(value)은 식(expression)이 평가(evaluate)되어 생성된 결과 
> 평가: 식을 해석해서 값을 생성하는 것을 참조하는 것

```javascript
// 10 + 20 은 평가되어 숫자 값 30을 가진다
10 + 20; // 30
```

- 모든 값은 데이터 타입(문자/숫자)을 가진다
- 모든 값은 메모리에 2진수, 즉 비트의 나열로 저장된다
  - 이러한 비트의 나열은 데이터 타입에 따라 다르게 해석될 수 있다
- 변수 : 하나의 값을 저장하기 위해 확보된 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름





## 5.2 리터럴

> 리터럴(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법(notation)

```jsx
// 숫자 리터럴 3
// 문자 리터럴 '', ""
// 배열 리터럴 []
// 객체 리터럴 {}
// 정규 표현식 리터럴: /[A-Z]+/g
```

- 값을 생성하기 위해 미리 약속한 표기법
- 자바스크립트 엔진은 코드가 실행되는 시점인 **런타임**에 리터럴을 평가해 값을 생성



## 5.3 표현식

> 표현식(expression)은 값으로 평가될 수 있는 문(statement)
> 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다

```jsx
// 리터럴 표현식
'Hello'

// 식별자 표현식(선언이 이미 존재한다고 가정했을 때)
arr[1]

// 연산자 표현식
10 + 20

// 함수/메서드 호출 표현식(선언이 이미 존재)
hello();
```

- 리터럴은 표현식
  - 자바스크립트 엔진에 의해 평가되어 값을 생성하므로



## 5.4 문

> 문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위 
> 토큰(token): 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미

- 프로그램: 문의 집합

- 프로그래밍: 문을 작성하고 순서에 맞게 나열하는 것

- 문의 구분

  - 선언문, 할당문, 조건문, 반복문

  ```jsx
  var x // 선언문
  x = 5 // 할당문
  function foo (){} // 함수 선언문
  if (x > 1) { console.log(x); } // 조건문
  for ( var i = 0; i < 2; i++ ) { console.log(x); } // 반복문
  ```



## 5.5 세미콜론과 세미콜론 자동 삽입 가능

> 세미콜론은 문의 종료를 나타냄 
> 세미콜론 자동 삽입 기능(ASI: Automatic Semicolon Insertion)이 있으므로 생략이 가능하다

- 문이 끝날 때

- 단, 0개 이상의 문을 중괄호로 묶은 코드블록 

  ```
  {...}
  ```

   뒤에는 세미콜론을 붙이지 않는다

  - 자체 종결성(self-closing)을 갖기 때문

- 단, 세미콜론 자동 삽입 기능의 동작과 개발자의 예측이 일치하지 않는 경우가 있기도 하므로 세미콜론의 사용 여부에 논란이 있기도 함

```jsx
function foo() {
	return 
		{}
}
// ASI 는 => return; {};
// 개발자의 예측 => return {};
```



## 5.6 표현식인 문과 표현식이 아닌 문

> 문은 표현식인 문과 표현식이 아닌 문으로 구분된다.

- 가장 간단한 구분 방법: 변수에 할당해 보는 것
- 표현식인 문: 변수에 할당할 수 있다 (값으로 평가됨)
- 표현식이 아닌 문: 변수에 할당할 수 없다 (값으로 평가할 수 없으므로)

```jsx
var x // 변수 선언문은 값처럼 사용할 수 없다 - 따라서 표현식이 아닌 문
x = 100 // 할당문은 값으로 사용할 수 있다 - 표현식인 문
```

- 크롬 개발자 도구
  - 표현식이 아닌 문은 `undefined`를 출력한다
  - 표현식인 문은 언제나 평가된 값을 반환한다