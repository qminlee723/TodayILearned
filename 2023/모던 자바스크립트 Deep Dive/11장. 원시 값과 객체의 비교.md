# 11장. 원시 값과 객체의 비교

> 원시 타입과 객체 타입은 근본적으로 다르다.
>
> 원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)
>
> 객체 타입의 값, 즉 객체는 변경 가능한 값(mutable value)

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

> 원시 타입(primitive type)의 값

- 원시 타입의 값은 변경 불가능
  - 읽기 전용 값
  - 데이터의 신뢰성 보장
- 변수 값을 변경하게 되면
  - 원시 값을 재할당하는 것이 아니라,
  - 새로운 메모리 공간 확보 > 재할당한 값 저장 > 변수가 참조하던 메모리 공간의 주소 변경



### 11.1.2. 문자열과 불변성

- C와 달리 자바스크립트는 원시 타입인 문자열 타입을 제공

  - 문자열이 저장된 주소가 변경

- 문자열은 유사 배열

  - 배열과 유사하게 인덱스를 사용해 각 문자에 **접근**할 수 있다
  - 하지만 문자열은 원시 값이므로 변경할 수 없다

  ```javascript
  var str = 'string';
  
  console.log(str[0]); // 's'
  
  str[0] = 'S';
  
  console.log(str); // 'string'
  ```



### 11.1.3 값에 의한 전달

> 변수에 변수를 할당했을 때 무엇이 전달되는가?

 ```javascript
 var score = 80;
 var copy = score;
 
 console.log(score); // 80
 console.log(copy); // 80
 ```

- 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 **복사**되어 전달
  - 값에 의한 전달 === 참조에 의한 전달 === 공유에 의한 전달
  - score와  copy의 값 80은 다른 메모리 공간에 저장된 별개의 값

```javascript
score = 100;

console.log(score); // 100
console.log(copy); // 80
```

- 값에 의한 전달
  - 자바스크립트 용어가 아님
  - 엄격하게 표현하며 변수에는 값이 아니라 **메모리 주소가 전달**되는 것
- 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것



## 11.2 객체

> 프로퍼티의 갯수가 정해져 있지 않음
>
> 동적으로 추가되고 삭제할 수 있음
>
> 프로퍼티 값에도 제약이 없음
>
> 따라서, 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없다

- 자바스크립트는 클래스 없이 객체 생성이 가능하며, 객체 생성 이후에도 동적으로 프로퍼티와 메서드를 추가 가능
  - 자바, C++ 같은 클래스 기반 객체 지향 프로그래밍 언어는 사전에 정의된 클래스를 기반으로 객체를 생성
  - 사용성은 뛰어나지만, 성능 면에서는 생성과 프로퍼티 접근에 비용이 더 많이 드는 비효율적인 방식
    - 따라서, 히든 클래스(hidden class)라는 방식을 사용해 C++ 객체의 프로퍼티에 접근하는 정도의 성능을 보장

