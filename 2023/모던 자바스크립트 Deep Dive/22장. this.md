# 22장. this

## 22.1 `this` 키워드

> `this` 는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-referencing variable)이다. `this`를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.

* 동작을 나타내는 메서드는 자신이 속한 객체의 상태, 즉 프로퍼티를 참조하고 변경할 수 있어야 한다. 이 때 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 **자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야** 한다.

  * 자기 자신이 속한 객체를 재귀적으로 참조하는 방식 ❌
  * `this` 식별자를 이용해 참조하는 방식 ✅

* `this`

  * 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있다
  * 함수를 호출하면 `arguments` 와 `this` 객체가 암묵적으로 함수 내부에 전달된다. `arguments`를 지역 변수처럼 사용할 수 있는 것처럼 `this` 도 사용 가능하다
  * 단, `this`가 가리키는 값, 즉 `this` 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.
    * 바인딩
      * **식별자**와 **값**을 연결하는 과정
      * 변수 선언은 변수 이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는 것
      * `this` 바인딩은 `this`와 `this`가 가리킬 객체를 바인딩

  

## 22.2 함수 호출 방식과 `this` 바인딩

> `this` 바인딩은 **함수 호출 방식**, 즉 함수가 어떻게 호출되었는지에 따라 **동적으로 결정**된다

* 다양한 함수 호출 방식
  1. 일반 함수 호출
  2. 메서드 호출
  3. 생성자 함수 호출
  4. `Function.prototype.apply/call/bind` 메서드에 의한 간접 호출

### 22.2.1 일반 함수 호출

>  `this`에는 **전역 객체(global object)**가 바인딩된다

* strict mode가 적용된 일반 함수 내부의 this
  * undefined
* 메서드 내에서 정의한 중첩 함수가 일반 함수로 호출될 때
  * 전역 객체가 바인딩
* 콜백 함수가 일반 함수로 호출될 때
  * 전역 객체가 바인딩



### 22.2.2 메서드 호출

> 메서드 내부의 `this`에는 **메서드를 호출한 객체**, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체가 바인딩된다. 

* 메서드 내부의 this는 어디에 바인딩될까?
  *  메서드를 소유한 객체 vs 메서드를 호출한 객체

```javascript
const person = {
  name: 'Lee',
  getName() {
    return this.name;
  }
};

console.log(person.getName()); // Lee // 호출한 객체
```



### 22.2.3 생성자 함수 호출

> 생성자 함수 내부의 `this`에는 **생성자 함수가 (미래에) 생성할 인스턴스**가 바인딩된다.

```javascript
function Circle(radius) {
	this.radius = radius;
  this.getDiameter = function() {
    return 2 * this.radius;
  };
}

const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성 
const circle2 = new Circle(10);
```





### 22.2.4 `Function.prototype.apply/call/bind` 메서드에 의한 간접 호출

> `apply`, `call`, `bind` 메서드는 `Function.prototype`의 메서드다. 즉, 이들 메서드는 모든 함수가 상속받아 사용가능하다
> 해당 메서드에서 첫번째 인수로 전달된 객체와 바인딩된다.

* `apply`와 `call`메서드의 본질적인 기능은 함수를 호출하는 것이다. 
  * 함수를 호출하면서 첫번째 인수로 전달한 특정 객체를 호출한 함수의 `this`에 바인딩
  * 호출할 함수에 인수를 전달하는 방식만 다를 뿐 동일하게 동작
    * `apply` 의 경우 호출할 함수의 인수를 배열로 묶어 전달
    * `call`의 경우 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달
      * 위의 예제가 헷갈린다고? 당연하다 27장 배열에서 알아보자
* `bind`는 함수를 호출하지 않고 `this`로 사용할 객체만 전달