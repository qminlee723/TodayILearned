# 🚀 SQL 자격검정 실전문제



## 과목 I - 데이터 모델링의 이해

### 🌱 제 1장 데이터 모델링의 이해

#### 데이터모델링이란?

* <u>정보시스템을 구현</u>하기 위한 데이터 관점의 <u>업무 분석 기법</u>

* 현실세계의 데이터(what)에 대해 <u>약속된 표기법에 의해 표현</u>하는 과정

* <u>데이터베이스를 구축</u>하기 위한 <u>분석/설계</u>의 과정

#### 데이터모델링의 목적

* 업무정보를 구성하는 기초가 되는 정보들에 대해 일정한 표기법에 의해 표기함으로써 정보시스템 구축의 대상이 되는 <u>업무 내용을 정확하게 분석</u>하는 것
* 분석된 모델을 가지고 <u>실제 데이터베이스를 생성</u>하여 개발 및 데이터관리에 사용하기 위한 것

#### 데이터 모델링을 할 때 유의할 사항

* 중복(Duplication)

  데이터 모델은 데이터베이스가 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록 함

* 비유연성(Inflexibility)

  데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄인다.

  유연하지 못하면 유지보수가 어려움

* 비일관성(Inconsistency)

  데이터모델링을 할 때 데이터와 데이터 간의 상호 연관 관계에 대해 명확하게 정의한다면, 이러한 위험을 사전에 예방할 수 있다.

  사용자가 처리하는 프로세스 혹은 이와 관련된 프로그램과 테이블의 연계성을 높이는 것은 데이터모델이 업무 변경에 대해 취약하게 만드는 단점에 해당한다.

  데이터의 중복이 없더라도, 비일관성은 발생할 수 있다

  * 신용 상태에 대한 갱신 없이 고객의 납부 이력 정보를 갱신하는 경우 - 개발자가 서로 연관된 다른 데이터와 모순된다는 고려 없이 일련의 데이터를 수정할 수 있기 때문에 이와 같은 문제가 발생할 수 있다.

#### 데이터모델링의 종류

* 개념적 데이터모델링

  추상화 수준이 높고, 업무중심적이고 포괄적인 수준의 모델링 진행

  전사적 데이터모델링, EA(Enterprise Architecture)수립시 많이 이용

* 물리적 데이터모델링

  실제로 데이터베이스에 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려하여 설계

* 논리적 데이터모델링

  시스템으로 구축하고자 하는 업무에 대해 Key, 속성, 관계 등을 정확하게 표현

  재사용성이 높음

#### 데이터베이스 스키마 구조 

* 1단계: 외부 스키마(External Schema)

  사용자 View

  전체 데이터베이스의 한 논리적인 부분으로 볼 수 있으므로 서브 스키마(Sub Schema)라고도 한다.

  사용자나 응용프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의 한 것

* 2단계: 개념 스키마(Conceptual Schema)

  전체적인 View

  데이터베이스의 전체적인 논리적 구조로서, 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재

  데이터모델링은 통합관점의 뷰를 가지고 있는 개념 스키마를 만들어 가는 과정으로 이해할 수 있음

* 3단계: 내부 스키마(Internal Schema)

  저장 스키마

  실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의하고, 저장 데이터 항목의 표현방법, 내부 레코드의 물리적 순서 등을 나타냄

#### ERD

* ERD 작성 순서

  1. 엔터티를 그린다
  2. 엔터티를 적절하게 배치한다
  3. 엔터티간 관계를 설정한다
  4. 관계명을 기술한다
  5. 관계의 참여도를 기술한다
  6. 관계의 필수여부를 기술한다

* ERD에 대한 설명

  1976년 피터 첸(Peter Chen)에 의해 Entity-Relationship Model이라는 표기법이 만들어졌다.

  데이터모델링에서 가장 중요한 엔터티를 왼쪽 상단에 배치하고, 이것을 중심으로 다른 엔터티를 나열하면서 전개하면 사람의 눈이 따라가기 편리한 데이터 모델을 작성할 수 있다. 해당 업무에서 가장 중요한 엔터티는 왼쪽 상단에서 조금 아래쪽 중앙에 배치하여 전체 엔터티와 어울릴 수 있또록 하면, 향후 관련 엔터티와 관계선을 연결할 때 선이 꼬이지 않고 효과적으로 배치할 수 있게 된다.

#### Entity의 특징

* 반드시 해당 업무에서 필요하고 관리하고자 하는 정보여야 한다
* 유일한 식별자에 의해 식별 가능해야 한다
* 영속적으로 존재하는 인스턴스의 집합이어야 한다(두 개 이상)
* 업무 프로세스에 의해 이용되어야 한다
* 반드시 속성이 있어야 한다
* 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다.
  * 단, 통계성 엔터티나 코드성 엔터티의 경우 관계를 생략할 수 있다

#### Entity의 종류

* 기본 엔터티(키 엔터티)
* 중심 엔터티(메인 엔터티)
* 행위 엔터티
* 개념 엔터티

#### Entity, 인스턴스, 속성, 속성값과의 관계

* 한 개 이상의 **엔터티**는 <u>두 개 이상의 "인스턴스"</u>의 집합이어야 한다
* 한 개의 **엔터티**는 <u>두 개 이상의 "속성"</u>을 갖는다
* 한 개의 **속성**은 <u>한 개의 "속성값"</u>을 갖는다

#### 속성(Attribute)

* 업무에서 필요로 하는 <u>인스턴스에서 관리</u>하고자 하는, 의미상 더 이상 분리되지 않는 <u>최소의 데이터 단위</u>
* 엔터티에 대한 <u>자세하고 구체적인 정보</u>를 나타낸다
* 하나의 인스턴스에서 각각의 속성은 <u>하나의 속성값</u>을 갖는다
* 속성도 <u>집합</u>이다
* 각 속성은 가질 수 있는 <u>값의 범위값</u>이 있는데, 이를 그 속성의 <u>도메인(domain)</u>이라고 하며, 엔터티 내에서 속성에 대한 데이터 타입과 크기 그리고 제약사항을 지정하는 것이다

#### 속성의 종류

* 기본속성(Basic)

  <u>원래</u> 가지고 있어야 하는 속성

  회원ID, 이름, 계좌번호, 주문일자 등

* 설계속성(Designed)

  데이터 모델링 과정에서 발생되는 속성

  상품코드, 지점코드 등

* 파생속성(Derived)

  데이터를 조회할 때 빠른 성능을 낼 수 있도록 하기 위해 <u>원래 속성의 값을 계산</u>하여 저장할 수 있도록 만든 속성

  합계, 평균 등

#### 속성의 명칭

* 해당업무에서 사용하는 이름을 부여
* 서술식 속성명은 사용하지 않는다
* 약어사용은 가급적 제한한다
* 전체 데이터모델에서 <u>유일성</u> 확보하는 것이 좋다

#### 데이터모델링의 관계

* 존재적 관계
* 행위에 의한 관계
* 단, ERD에서는 관계를 연결할 때 존재와 행위를 구분하지 않고 단일화된 표기법 사용
* 단,  UML(Unified Modeling Language)에는 클래스다이어그램의 관계 중 연관관계(association-실선)와 의존관계(dependency-점선)가 있고, 다른 표기법을 가지고 표현하게 되어 있다. 

#### 관계의 표기법

* 관계명(Membership)

* 관계차수(Degree/Cardinality)

  1:1, 1:M, M:N

* 관계선택사양(Optionality)

  필수관계, 선택관계

#### 엔터티 사이에 정의한 관계 체크사항

* 두 개의 엔터티 사이 관심 있는 연관규칙이 존재하는가?
* 두 개의 엔터티 사이에 정보의 조합이 발생되는가?
* 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb)가 있는가?
* 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?

#### 관계 읽기

* 기준(Source) 엔터티를 한 개(One) 또는 각(Each)으로 읽는다
* 대상(Target) 엔터티를의 관계참여도 즉 개수(하나, 하나 이상)를 읽는다
* 관계선택사양과 관계명을 읽는다

#### 식별자(Identifier)의 분류관계

| **분류**            | **식별자** | **설명**                                                     |
| ------------------- | ---------- | ------------------------------------------------------------ |
| **대표성 여부**     | 주식별자   | 엔터티 내 각 어커런스를 구분할 수 있는 <u>구분자</u>이며, <u>타 엔터티와 참조관계를 연결</u>할 수 있는 식별자 |
|                     | 보조식별자 | 엔터티 내 각 어커런스를 구분할 수 있는 구분자이나, 대표성을 가지지 못해 참조관계 연결을 못함 |
| **스스로 생성여부** | 내부식별자 | 엔터티 내부에서 스스로 만들어지는 식별자                     |
|                     | 외부식별자 | 타 엔터티와의 관계를 통해 타 엔터티로부터 받아오는 식별자    |
| **속성의 수**       | 단일식별자 | 하나의 속성으로 구성된 식별자                                |
|                     | 복합식별자 | 둘 이상의 속성으로 구성된 식별자                             |
| **대체 여부**       | 본질식별자 | 업무에 의해 만들어지는 식별자                                |
|                     | 인조식별자 | 원조식별자가 복잡한 구성을 가지고 있기 때문에 인위적으로 만든 식별자 |

* 엔터티 내 대표성을 가지는가?
  * 주식별자(Primary)
    * <u>유일성</u>: 주 식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 함
    * <u>최소성</u>: 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함
    * <u>불변성</u>: 지정된 주식별자의 값은 자주 변하지 않는 것이어야 함
    * <u>존재성</u>: 주식별자가 지정이 되면 반드시 값이 들어와야 함
    * 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다
    * 명칭, 내역 등과 같이 이름으로 기술되는 것들은 가능하면 주식별자로 지정하지 않는다
    * 복합으로 주식별자를 구성할 경우, 너무 많은 속성이 포함되지 않도록 한다
  * 보조식별자(Alternate)
* 엔터티 내 스스로 생성되었는가?
  * 내부식별자(Internal)
  * 외부식별자(External)
* 단일 속성으로 식별이 가능한가?
  * 단일식별자(Single)
  * 복합식별자(Composit)
* 원래 업무적으로 의마가 있던 식별자 속성을 대체하여 일련번호와 같이 새롭게 만든 식별자인가?
  * 본질식별자
  * 인조식별자

#### 식별자와 비식별자관계 비교

| 항목               | 식별자관계                                                   | 비식별자관계                                                 |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 목적               | 강한 연결관계 표현                                           | 약한 연결관계 표현                                           |
| 자식 주식별자 영향 | 자식 주식별자의 구성에 포함됨                                | 자식 일반 속성에 포함됨                                      |
| 표기법             | 실선                                                         | 점선                                                         |
| 연결 고려사항      | - 반드시 부모 엔터티 종속<br />- 자식 주식별자구성에 부모 주식별자 포함 <br />- 상속받은 주식별자 속성을 타 엔터티에 이전 필요 | - 약한 종속관계<br />- 자식 주식별자구성을 독립적으로 구성 <br />- 상속받은 주식별자 속성을 타 엔터티에 차단 필요<br />- 부모쪽의 관계참여가 선택관계<br />- SQL문의 복잡성이 증가되는 것을 방지하기 위해 고려<br />(복잡성은 중요한 고려사항은 아님) |

