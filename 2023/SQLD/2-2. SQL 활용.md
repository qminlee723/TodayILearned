# 🚀 SQL 자격검정 실전문제



## 과목 II - SQL 기본 및 활용

### 🌱 제 2장 SQL 활용

#### 순수 관계 연산자와 SQL 문장 비교

**`SELECT` `PROJECT` `JOIN` `DIVIDE`**

* `SELECT` 연산은 `WHERE`절로 구현
* `PROJECT`연산은 `SELECT`절로 구현
* (NATURAL) `JOIN` 연산은 다양한 `JOIN`기능으로 구현
* `DIVIDE` 연산은 현재 사용되지 않음

#### ANSI/ISO SQL에서 표시하는 FROM절의  JOIN형태

* `INNER JOIN`
* `NATURAL JOIN`
  * `JOIN`칼럼에 대해서는 `ALIAS`나 테이블 이름과 같은 접두사를 붙일 수 없다.
* `USING` 조건절
  * `JOIN`칼럼에 대해서는 `ALIAS`나 테이블 이름과 같은 접두사를 붙일 수 없다.
* `ON` 조건절
* `CROSS JOIN`
* `OUTER JOIN(LEFT, RIGHT, FULL)`

#### INNER JOIN

`INNER JOIN`은 `OUTER JOIN`과 대비하여 내부 조인이라고 하며, `JOIN` 조건에서 동일한 값이 있는 행만 반환한다

#### OUTER JOIN

두 테이블 모두에서 데이터가 있어야 결과를 반환하는 내부조인과 달리, 한 쪽에만 데이터가 있어도 결과를 반환한다

* LEFT OUTER JOIN
  * 조인 수행시 먼저 표기된 좌측 테이블에 해당하는 데이터를 먼저 읽은 후, 나중 표기된 우측 테이블에서 JOIN 대상 데이터를 읽어 온다.
  * 즉, Table A와 B가 있을 때 (Table 'A'가 기준이 됨), A와 B를 비교해서 B의 JOIN 칼럼에서 같은 값이 있을 때 그 해당 데이터를 가져오고, B의 JOIN 칼럼에서 같은 값이 없는 경우에는 B 테이블에서 가져오는 칼럼들은 NULL 값으로 채운다

* FULL OUTER JOIN
  * 조인 수행시 좌측, 우측 테이블의 모든 데이터를 읽어 JOIN하여 결과를 생성한다.
  * 즉, Table A와 B가 있을 때 (Table 'A'와 'B' 모두 기준이 됨), RIGHT OUTER JOIN과 LEFT OUTER JOIN의 결과를 합집합으로 처리한 결과와 동일 

#### OUTER JOIN 문장 예시

* LEFT OUTER JOIN

  ```sql
    SELECT X.KEY1, Y.KEY2 FROM TAB1 X LEFT OUTER JOIN TAB2 Y ON (X.KEY1=Y.KEY2)
  ```

* RIGHT OUTER JOIN

  ```sql
    SELECT X.KEY1, Y.KEY2 FROM TAB1 X RIGHT OUTER JOIN TAB2 Y ON (X.KEY1=Y.KEY2)
  ```

* FULL OUTER JOIN

  ```sql
    SELECT X.KEY1, Y.KEY2 FROM TAB1 X FULL OUTER JOIN TAB2 Y ON (X.KEY1=Y.KEY2)
  ```

#### CROSS JOIN

* 테이블간 JOIN 조건이 없는 경우 생길 수 있는 모든 데이터의 조합을 말함
  * 결과는 양쪽 집합의 M*N 건의 데이터 조합이 발생한다 (따라서 데이터 조회의 의미는 많이 없음)
* 테스트 용도의 대용량의 데이터를 생성할때 쓰임

#### 카티시안 곱

테이블 사이의 JOIN조건이 없는 경우엔 카티시안 곱이 발생

WHERE절에 조건을 주지 않거나  `CROSS JOIN`시 발생

즉, 두 테이블의 데이터를 기준으로 가능한 모든 조합의 데이터가 조회됨

####  집합 연산자의 종류

집합 연산자는 SQL에서 위에 정의된 연산자가 먼저 수행된다

| 집합 연산자 | 연산자의 의미                                                |
| ----------- | ------------------------------------------------------------ |
| UNION       | 여러 개의 SQL문의 결과에 대한 합집합으로 결과에서 <u>모든 중복된 행은 하나의 행</u>으로 만든다 |
| UNION ALL   | 여러 개의 SQL문의 결과에 대한 합집합으로 <u>중복된 행도 그대로</u> 결과로 표시된다.<br />즉, 단순히 결과만 합쳐놓은 것이다.<br />일반적으로 여러 질의 결과가 상호 배타적인(Exclusive)일 때 많이 사용한다. <br />개별 SQL문의 결과가 서로 중복되지 않는 경우, UNION과 결과가 동일하다. (결과의 정렬 순서에는 차이가 있을 수 있음) |
| INTERSECT   | 여러 개의 SQL문의 결과에 대한 <u>교집합</u>니다. 중복된 행은 하나의 행으로 만든다 |
| EXCEPT      | 앞의 SQL문의 결과에서 뒤의 SQL문의 결과에 대한 <u>차집합</u>니다. 중복된 행은 하나의 행으로 만든다<br />(일부 데이터베이스는 MINUS를 사용함) |

#### UNION

`UNION ALL` 을 사용하는 경우, 칼럼 ALIAS는 첫번째 SQL 모듈 기준으로 표시되며, 정렬 기준은 마지막 SQL 모듈에 표시하면 됨(82번)

#### 일반 집합 연산자를 SQL과 비교

* UNION 연산은 `UNION` 기능으로
* INTERSECTION 연산은 `INTERSECT` 기능으로
* DIFFERENCE 연산은 `EXCEPT`(Oracle은 `MINUS`) 기능으로
* PRODUCT 연산은 `CROSS JOIN` 기능으로 구현됨

#### 계층형 질의

* 테이블에 계층형 데이터가 존재하는 경우, 데이터를 조회하기 위해 계층형 질의(Hierarchical Query)를 사용한다

* 계층형 데이터란 동일 테이블에 계층적으로 상위와 하위 데이터가 포함된 데이터를 말한다
* `SQL Server`에서의 계층형 질의문은 CTE(Common Table Expression)를 재귀 호출함으로써 계층 구조를 전개한다
* `SQL Server`에서의 계층형 질의문은 앵커 멤버를 실행하여 기본 결과 집합을 만들고, 이후 재귀 멤버를 지속적으로 실행한다
* `ORACLE`의 계층형 질의문에서 `WHERE`절은 몯느 전개를 진행한 이후 필터 조건으로서 조건을 만족한는 데이터만을 추출하는데 활용된다
* `ORACLE`의 계층형 질의문에서  `PRIOR` 키워드는  `CONNECT BY` 절 뿐만 아니라 `SELECT`, `WHERE` 절에서도 사용할 수 있다

#### PRIOR

* `CONNECT BY` 절에 사용되며, 현재 읽은 칼럼을 지정 (SELECT, WHERE 에도 사용가능)

* `PRIOR 자식 = 부모` 형태를 사용하면 계층구조에서 부모 데이터에서 자식 데이터(부모 -> 자식) 방향으로 전개하는 <u>순방향 전개</u>를 한다
* `PRIOR 부모 = 자식` 형태를 사용하면 반대로 자식 데이터에서 부모 데이터(자식 -> 부모)방햐응로 전개하는 <u>역방향 전개</u>를 한다

#### START WITH

* 계층 구조 전개의 시작 위치를 지정하는 구문
* 루트 데이터를 지정(액세스)

#### ORDER SIBLINGS BY

* 형제 노드(동일레벨) 사이에서 정렬을 수행

#### SELF JOIN

* 동일 테이블 사이의 조인을 말한다
* 따라서 FROM 절에 동일 테이블이 두 번 이상 나타난다
* 동일 테이블 사이의 조인 수앻ㅇ시 테이블과 칼럼 이름이 모두 도잉ㄹ하기 때문에 식별을 위해 반드시 테이블 별칭(ALIAS)를 사용해야 한다

```sql
SELECT ALIAS명1.칼렴명, ALIAS명2.칼럼명, ... FROM 테이블 ALIAS명1, 테이블 ALIAS명2 WHERE ALIAS명1.칼럼명2 = ALIAS명2.칼럼명1;
```

#### 반환되는 데이터의 형태에 따른 서브쿼리 분류

| 서브쿼리 종류                                   | 설명                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| Single Row 서브쿼리<br />(단일행 서브쿼리)      | 서브쿼리의 실행 결과가 항상 1건 이하인 서브쿼리를 의미한다<br />단일 행 서브쿼리는 단일 행 비교 연산자와 함께 사용된다<br />단일 행 비교 연산자에는 `=`, `<`, `<=`, `>`, `>=`, `<>` 이 있다 |
| Multi Row 서브쿼리<br />(다중 행 서브쿼리)      | 서브쿼리의 실행 결과가 여러 건인 서브쿼리를 의미한다<br />다중행 서브쿼리는 다중 행 비교 연산자와 함께 사용된다<br />다중 행 비교 연산자에는 `IN`,` ALL`, `ANY`, `SOME`, `EXISTS`가 있다 |
| Multi Column 서브쿼리<br />(다중 칼럼 서브쿼리) | 서브쿼리의 실행 결과로 여러 칼럼을 반환한다<br />메인 쿼리의 조건절에 여러 칼럼을 동시에 비교할 수 있다<br />서브쿼리와 메인쿼리에서 비교하고자 하는 칼럼 개수와 칼럼의 위치가 동일해야 한다<br />SQL Server에서는 지원하지 않는다 |

* 서브쿼리는 `SELECT`절, `FROM`절, `HAVING`절, `ORDER BY`절 등에서 사용이 가능하다
* 연관(Correlated) 서브쿼리는 서브쿼리가 메인쿼리 컬럼을 포함하고 있는 형태의 서브쿼리이다

#### 서브쿼리 사용시 주의사항

* 서브쿼리를 괄호로 감싸 사용한다
* 서브쿼리는 단일행 또는 복수행 비교 연산자와 함께 사용 가능하다
  * 단일 행 비교 연산자는 서브쿼리의 결과가 반드시 1건 이하여야하고, 복수행 비교 연산자는 서브쿼리의 결과건수와 관계없다
* 서브쿼리에서는 `ORDER BY` 를 사용하지 못한다. `ORDER BY`는`SELECT`절에서 오직 한 개만 올 수 있기 때문에 메인쿼리의 마지막 문장에 위치한다

* 다중 행 서브쿼리 비교 연산자는 단일 행 서브쿼리의 비교연산자로도 사용할 수 있다
  * 단 단일행 서브쿼리의 비교연산자는 다중 행 서브쿼리 비교연산자로 사용할 수 없다
* 비 연관 서브쿼리는 주로 메인쿼리에 값을 제공하는 위한 목적으로 사용된다
* 메인 쿼리의 결과가 서브쿼리로 제공될 수도 있고, 서브쿼리의 결과가 메인쿼리로 제공될 수 있다
* `SELECT`절에 사용된 서브쿼리는 <u>스칼라 서브쿼리</u>라고도 한다
  * JOIN으로 동일한 결과 추출이 가능하다

#### Inline View

* `FROM` 절에서 사용되는 서브쿼리

* 동적 뷰(Dynamic View)라고도 함
* 서브쿼리의 결과가 마치 실행 시에 동적으로 생성된 테이블인 것처럼 사용할 수 있음
* SQL문이 실행될 때만 임시적으로 생성되는 동적인 뷰이기 때문에, 데이터베이스에 해당 정보가 저장되지 않는다
* 서브쿼리의 결과가 마치 실행시에 동적으로 생성된 테이블인 것처럼 사용가능하다
* SQL문장 중 테이블 명이 올 수 있는 곳에서 사용할 수 있다

#### 뷰

* 뷰는 단지 정의만을 가지고 있으며, 실행 시점에 질의를 재작성하여 수행한다
* 실제 데이터를 저장하고 있는 뷰를 생성하는 기능을 지원하는 DBMS도 있다

* 뷰 사용의 장점

  * 독립성
    * 테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 된다

  * 편리성
    * 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성가능하다
    * 해당 형태의 SQL 문을 자주 사용할 때 뷰를 이용하면 편리하게 사용가능하다

  * 보안성
    * 직원의 급여정보와 같이 숨기고 싶은 정보가 존재한다면, 뷰를 생성할 때 해당 칼럼을 빼고 생성함으로써 사용자에게 정보를 감출 수 있다

#### CUBE

* Grouping Columns이 가질 수 있는 모든 경우에 대해 Subtotal 을 생성해야 하는 경우에는 CUBE를 사용하는 것이 바람직하나, ROLLUP에 비해 시스템에 많은 부담을 주므로 사용해 주의해야 함
* 결합 가능한 모든 값에 대하여 다차원 집계를 생선한다
* 결과에 대한 정렬이 필요한 경우는 `ORDER BY`절에 명시적으로 정렬 칼럼이 표시가 되어야 한다

####  GROUPING SETS

* 다양한 소계 집합을 만들 수 있다
* GROUPING SETS에 표시된 인수들에 대한 개별 집계를 구할 수 있으며, 이 때 표시된 인수들 간에는 계층 구조인 ROLLUP 과 달리 평등한 관계이므로 인수의 순서가 바뀌어도 결과는 같다
* GROUPING SETS 함수도 결과에 대한 정렬이 필요한 경우, `ORDER BY`절에 명시적으로 정렬 칼럼이 표시되어야 한다

#### 윈도우 함수(Window Function, Analytic Function)

* Partition 과 GROUP BY 구문은 의미적으로 유사하다
* Partition 구문이 없으면 전체 집합을 하나의 Partition으로 정의한 것과 같다
* 윈도우 함수 처리는 결과에 대한 함수처리기 때문에 결과 건수는 줄지 않는다
* 윈도우 함수 적용 범위는 Partition을 넘을 수 없다
* `GROUP BY` 절의 집합을 원본으로 하는 데이터를 `WINDOW FUNCTION`과 함께 사용한다면,  `GROUP BY`절과 함께 `WINDOW FUNCTION`을 사용한다고 하더라도 오류가 발생하지 않는다

#### RANK

*  `ORDER BY`  를 포함한 QUERY 문에서 특정 항목(칼럼)에 대한 순위를 구하는 함수이며, 동일한 값에 대해서는 동일한 순위를 부여하게 된다

#### DENSE_RANK 

* RANK 함수와 흡사하나, 동일한 순위를 하나의 건수로 취급하는 것이 다른 점이다

#### ROW_NUMBER 

* RANK나 DENSE_RANK 함수가 동일한 값에 대해서는 동일한 순위를 부여하는데 반해, 동일한 값이라도 고유한 순위를 부여한다
* `ORDER BY` 절에 의해 정렬된 데이터에 동일 값이 존재하더라도 유일한 순위를 부여하는 함수
* 그룹 내에 유일한 순위를 추출할 때 사용할 수 있음

#### LAG/LEAD 함수

* 파티션별 윈도우에서 이전 몇 번째 행의 값을 가져올 수 있다
* 이후 몇 번째 행의 값을 가져오는 것은 LEAD 함수이며, SQL Server에서는 지원하지 않는다

#### 절차형 SQL 모듈, PL/SQL의 특징 (Procedural Language extention to SQL)

* SQL을 확장한 절차적 언어(Procedural Language)로, 크게 `Procedure`, ` Function`, `Trigger` 로 나뉘어진다
* `Procedure` 내부에 작성된 절차적 코드는 PL/SQL엔진이 처리하고, 일반적인 SQL문장은 SQL실행기가 처리한다
* PL/SQL로 작성된 `Procedure`, `User Defined Function` 은 작성자의 기준으로 <u>트랜잭션을 분할</u> 할 수 있으며, 또한 프로시저 내에서 다른 프로시저를 호출할 경우에 호출 프로시저의 트랜젝션과는 별도로 `PRAGMA AUTONOMOUS_TRANSACTION`을 선언하여 <u>자율 트랜잭션 처리</u>를 할 수 있다

* <u>Block구조</u>로 되어 있어 각 <u>기능별로 모듈화</u>가 가능하다
* 변수, 상수 등을 선언하여 SQL 문장 간 값을 교환한다 ( `WHERE` 절의 조건 등으로 대입 가능하다 )
* `IF`, `LOOP` 등의 절차형 언어를 사용하여 <u>절차적인 프로그램이 가능</u>하도록 한다
* DBMS 정의 에러나 사용자 정의 에러를 정의하여 사용할 수 있다
* <u>Oracle</u>에 내장되어 있으므로 Oracle을 지원하는 어떤 서버로도 프로그램을 옮길 수 있다
* 응용 프로그램의 <u>성능을 향상</u>시킨다
* 여러 SQL 문장을 Block으로 묶고, Block 전부를 서버로 보내기 때문에 <u>통신량을 줄일 수 있다</u>

#### 저장 모듈(Stored Module)

* SQL 문장을 <u>데이터베이스 서버에 저장</u>하여 사용자와 애플리케이션 사이에서 공유할 수 있도록 만든 일종의 SQL 컴포넌트 프로그램이며, 독립적으로 실행되거나 다른 프로그램으로부터 실행될 수 있는 <u>완전한 실행</u> 프로그램

* Oracle 의 저장 모듈에는 `Procedure`, `User Defined Function`, `Trigger`가 있음
* SQL을 로직과 함께 데이터베이스 내에 저장해 놓은 명령문의 집합을 의미
* 저장형 함수(사용자 정의 함수)는 단독적으로 실행되기 보다는 다른 SQL의 보조적인 역할을 한다

#### Trigger

* <u>전체 트랜잭션 작업</u>에 대해 발생되는 TRIGGER와 <u>각 행에 대해 발생</u>되는 TRIGGER 가 있다

* 테이블, 뷰, 데이터베이스 작업을 대상으로 정의할 수 있다
* `COMMIT`, `ROLLBACK` 과 같은 TCL 을 사용할 수 없다
* 데이터베이스에 의해 자동으로 호출되고 수행됨
* 특정 테이블에 대해서 `INSERT`, `UPDATE`, `DELETE` 와 같은 DML문이 수행될 때 데이터베이스에서 자동으로 동작하도록 작성된 프로그램
* 데이터베이스에 로그인하는 작업에도 정의할 수 있다
* 데이터의 무결성과 일관성을 위해 사용자 정의 함수를 사용한다

#### 프로시저와 트리거의 차이점

| 프로시저                       | 트리거                         |
| ------------------------------ | ------------------------------ |
| `CREATE Procedure` 문법 사용   | `CREATE Trigger` 문법 사용     |
| `EXECUTE` 명령어로 실행        | 생성 후 자동으로 실행          |
| `COMMIT`, `ROLLBACK` 실행 가능 | `COMMIT`, `ROLLBACK` 실행 안됨 |

