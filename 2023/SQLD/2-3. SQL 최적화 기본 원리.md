# 🚀 SQL 자격검정 실전문제



## 과목 II - SQL 기본 및 활용

### 🌱 제 3장 SQL 최적화 기본 원리

### 옵티마이저와 실행계획

#### 비용기반 옵티마이저(Cost Based Optimizer)

* 테이블 및 인덱스 등의 통계 정보를 활용하여 SQL문을 실행하는데 소요될 처리시간 및 CPU, I/O 자원량 등을 계산하여 가장 효율적일 것으로 예상되는 실행계획을 선택하는 옵티마이저
* 인덱스가 존재하더라도 전체 테이블 스캔이 유리하다고 판단할 수도 있다

#### 규칙기반 옵티마이저

* 제일 낮은 우선순위는 전체 테이블 스캔
* 제일 높은 우선순위는 ROWID를 활용해 테이블을 엑세스 하는 방법(Single row by rowid)

#### 실행계획

* SQL 처리를 위한 실행 절차와 방법을 표기한 것
* 조인 방법, 조인 순서, 액세스 기법 등이 포현된다
* CBO(Cost Based Optimizer)의 실행계획에는 단계별 예상 비용 및 건수 등이 표시된다
* 실행계획이 달라져도 실행 결과는 달라지지 않는다

#### 실행계획 정보의 구성요소

* 조인기법
* 연산
* 액세스 기법
* 최적화 정보
* 질의 처리 예상 비용
* 조인 순서

#### 실행계획을 읽는 순서

* 위에서 아래로, 안에서 밖으로 읽음 (아래 예제의 경우 3>4>2>6>5>1)

  ```sql
  1 NESTED LOOPS
  2		HASH JOIN
  3			TABLE ACCESS (FULL) TAB1
  4			TABLE ACCESS (FULL) TAB2
  5		TABLE ACCESS (BY ROWID) TAB3
  6			INDEX (UNIQUE SCAN) PK_TAB3
  ```

####  SQL 처리 흐름도(Access Flow Diagram)

* SQL 의 내부적인 처리 절차(실행계획)를 시각적으로 표현해준다
  * 이를 보고 실행 시간을 알 수는 없다
* 인덱스 스캔, 테이블 전체 스캔 등과 같은 액세스 기법이 표현된다

* 성능적인 측면도 표현 가능하다



### 인덱스

#### 인덱스

* 규칙기반 옵티마이저는 적절한 인덱스가 존재하면 항상 인덱스를 사용하려고 한다
* 기본 인덱스(Primary Key Index)는 UNIQUE & NOT NULL 의 제약조건을 가진다
* 보조 인덱스(Secondary Index)는 UNIQUE 인덱스가 아니라면 중복 데이터의 입력이 가능하다
* 자주 변경되는 속성을 인덱스로 선정할 경우 `UPDATE`, `DELETE` 성능에 좋지 않은 영향을 미치므로 인덱스 후보로 적절하지 않다
* 테이블의 전체 데이터를 읽는 경우는 인덱스가 거의 불필요하다
* 대량의 데이터를 조회하는 경우 인덱스를 이용한 조회보다는 테이블 전체 스캔 방식으로 조회하는게 더 빠를 수도 있다
* 인덱스를 구성하는 컬럼들의 순서는 데이터 조회시 성능적인 관점에서 매우 중요한 역할을 한다
* 인덱스를 구성하는 컬럼 외의 데이터가 UPDATE 될 때는 인덱스로 인한 부하가 걸리지 않는다
* 인덱스를 생성할 때 정렬 순서를 정할 수 있다 (오름차순, 내림차순)
* 인덱스는 조회만을 위한 오브젝트이며, 삽입, 삭제, 갱신의 경우 오히려 부하를 가중한다
* 인덱스가 존재하는 상황에서 데이터를 입력하면, 매번 인덱스 정렬이 일어나므로 데이터 마이그레이션같이 대량의 데이터를 삽입할 때는 모든 인덱스를 제거하고, 데이터 삽입이 끝난 후에 인덱스를 다시 생성하는 것이 좋다

#### 인덱스의 종류

* B-TREE 인덱스
  * 브랜치 블록과 리프 블록으로 구성되며, 브랜치 블록은 분기를 목적으로 하고 리프 블록은 인덱스를 구성하는 칼럼의 값으로 정렬된다
  * 일반적으로 OLTP 환경에서 가장 많이 사용된다
  * 관계형 데이터베이스의 주요 인덱스 구조이다
  * 일치 및 범위 검색에 적절한 구조이다
* BITMAP 인덱스
  * 시스템에서 사용될 질의를 시스템 구현 시에 모두 알 수 없는 경우인 DW 및 AD-HOC 질의 환경을 위해 설계되었으며, 하나의 인덱스 키 엔트리가 많은 행에 대한 포인터를 저장하고 있는 구조이다
* CLUSTERED 인덱스
  * 인덱스의 리프 페이지가 곧 데이터 페이지이며, 리프 페이지의 모든 데이터는 인덱스 키 컬럼 순으로 물리적으로 정렬되어 저장된다
  * ORACLE 의 IOT와 매우 유사하다

#### 인덱스 범위 스캔

* 결과 건수만큼 반환되지만, 결과가 없으면 단 한 건도 반환하지 않을 수 있다





### 조인 수행 원리

#### Nested Loop Join

* 랜덤 엑세스 방식으로 데이터를 읽는다
* 조인 칼럼에 적당한 인덱스가 있어서 자연조인(Natural Join)이 효율적일 때 유용하다
* Driving Table의 조인 데이터 양이 큰 영향을 주는 조인 방식이다
* 유니크 인덱스를 활용하여 수행시간이 적게 걸리는 소량 테이블을 온라인 조회하는 경우 유용하다
* 선택도가 낮은(결과 행의 수가 적은) 테이블이 선행 테이블로 선택되는 것이 일반적으로 유리하다
* OLTP의 목록 처리 업무에 많이 사용된다

#### Sort Merge Join

* 조인 칼럼을 기준으로 데이터를 정렬하여 조인을 수행한다

* 스캔 방식으로 데이터를 읽는다
* 랜덤 액세스로 NL JOIN에서 부담이 되던 넓은 범위의 데이터를 처리할 때 이용되던 조인 기법이다
* 정렬할 데이터가 많아 메모리에서 모든 정렬 작업을 수행하기 어려운 경우에는 임시 영역(디스크)을 사용하기 때문에 성능이 떨어질 수 있다
* 데이터 집계 업무에 많이 사용된다
* 조인 칼럼에 적당한 인덱스가 없어서 NL 조인이 비효율적일때 사용할 수 있다
* Driving Table의 개념이 중요하지 않은 조인 방식이다
* 조인 조건의 인덱스 유무에 영향받지 않는다
* EQUI JOIN, Non-EQUI JOIN 조건에서도 사용할 수 있다

#### Hash Join

* 조인 칼럼의 인덱스를 사용하지 않기 때문에, 조인 칼럼의 인덱스가 존재하지 않을 경우에도 사용할 수 있다
* 해쉬 함수를 이용하여 조인을 수행하기 때문에 '='로 수행하는 조인, 즉 동등조인(EQUI JOIN)에서만 사용할 수 있다
* 데이터 집계 업무에 많이 사용된다
* 행의 수가 작은 테이블을 선행 테이블로 선택하는 것이 유리하다
* Sort Merge Join 보다 일반적으로 우수한 성능을 보이지만,  Join 대상 테이블이 Join Key 컬럼으로 정렬되어 있을 때는 Sort Merge Join 이 우수한 성능을 낼 수도 있다

* 한 쪽 테이블이 주 메모리의 가용 메모리에 담길 정도로 충분히 작고, 해시 키 속성에 중복 값이 적을 때 효과적이다
  * 조인 컬럼에 적당한 인덱스가 없어서 자연조인(Natural Join)이 비효율적일 때
  * 자연조인(Natural Join)시 드라이빙(driving) 집합 쪽으로 조인 액세스량이 많아 Random 액세스 부하가 심할 때
  * 소트 머지 조인(Sort Merge Join)을 수행하기에 두 테이블이 너무 커서 소트(Sort)부하가 심할 때
